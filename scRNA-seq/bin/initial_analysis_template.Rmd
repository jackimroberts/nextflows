---
title: "initial scRNA-seq analysis, initial QC"
author: "Jacqueline Roberts, PhD"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output: html_document
params:
 collected_cellranger: ''
 transcriptome: ''
 velocity: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE,
                      cache = TRUE, cache.lazy = FALSE)

if (!require("pacman")) install.packages("pacman")

pacman::p_load(Seurat,sctransform,dplyr,tidyr,ggplot2,cowplot,qs,
	tidyverse,stringr,velocyto.R,SeuratWrappers,glmGamPoi,knitr)

set.seed(1234)
options(future.globals.maxSize=16777216000000)

# read in nextflow channel inputs
collected_cellranger <- params$collected_cellranger
transcriptome <- params$transcriptome
velocity <- as.logical(params$velocity)

# create directories for output
save_dir <- "seurat_results"
dir.create(save_dir)
dir.create(file.path(save_dir, "plots"))
```

### Transcriptome used: `r transcriptome`

### Parse the nextflow channel to extract sample info and cellranger paths

```{r parse_nextflow_channel}
# nextflow collected channel tuple format:
# [[id:x, name:x, condition:x, extra:x], cellranger_path, [id:y, name:y, condition:y, extra:y], cellranger_path2]

# extract tuple contents by removing brackets
# [id:x, name:x, condition:x, extra:x], cellranger_path, [id:y, name:y, condition:y, extra:y], cellranger_path2
clean_str <- substr(collected_cellranger, 2, nchar(collected_cellranger) - 1)
# parse individual sample information
# [id:x, name:x, condition:x, extra:x], cellranger_path
# [id:y, name:y, condition:y, extra:y], cellranger_path2
sample_tuples <- strsplit(clean_str," \\[")[[1]]

# initialize metadata and cellranger paths
metadata <- tibble()
cellranger_paths <- c()

# process each sample's data from the collected channel
for (sample_data in sample_tuples) {
  
  # extract metadata from entry
  # [id:x, name:x, condition:x, extra:x]
  meta_str <- str_extract(sample_data, "^[^\\]]*\\]")
  # remove brackets
  # id:x, name:x, condition:x, extra:x
  clean_str <- gsub("\\[|\\]", "", meta_str)
  
  # create a tibble
  meta_row <- as_tibble(strsplit(clean_str,", ")[[1]]) %>%
    separate_wider_delim(value,delim=":",names=c("title","val")) %>%
    pivot_wider(
        names_from = title,
        values_from = val
      ) %>%
    separate_wider_delim(extra,delim="|",names_sep = "_", too_few="align_start")
  
  # append to metadata table
  metadata <- bind_rows(metadata, meta_row)  
  
  # get cellranger path (string after the last comma)
  cellranger_path <- sub(".*,\\s*", "", sample_data)
  cellranger_paths <- c(cellranger_paths, cellranger_path)
}

kable(metadata, caption = "Sample Metadata")
write_tsv(metadata, file.path(save_dir, "sample_metadata.tsv"))
```

### Create seurat object and determine quality cut-offs

```{r create_seurat_objects}
# set up to create seurat objects, filter, and compile into list
mito_cutoff <- 5
seurat_objects <- list()

for (i in seq_along(cellranger_paths)) {
	path <- cellranger_paths[i]
	sample_name <- metadata$name[i]
	print(paste("Processing sample:", sample_name))
	
	# generate object and filter
	obj <- Read10X_h5(paste0(path,"/outs/filtered_feature_bc_matrix.h5"))
	obj <- CreateSeuratObject(counts = obj, project = sample_name, min.cells = 10, min.features = 200)
	
	# add all metadata columns to seurat object
	sample_metadata <- metadata[i, ]
	for (col_name in colnames(sample_metadata)) {
		if (col_name != "name") {  # skip name
			obj[[col_name]] <- sample_metadata[[col_name]]
		}
	}
	
	# add standard QC metrics
  	obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^mt-")
  	obj[["sex"]] <- PercentageFeatureSet(obj, pattern = c("^Xist|^Tsix"))
  	d <- density(obj$nFeature_RNA)
  	feat_min <- optimize(approxfun(d$x,d$y),interval=c(200,4000))$minimum
  	p<-VlnPlot(obj, features = c("nFeature_RNA"), pt.size=0)+geom_hline(yintercept =feat_min)+NoLegend()
  	q<-VlnPlot(obj, features = c("nCount_RNA"), pt.size=0)+NoLegend()
  	r<-VlnPlot(obj, features = c("percent.mt"), pt.size=0)+geom_hline(yintercept =mito_cutoff)+NoLegend()
  	print(plot_grid(p,q,r,ncol=3))
  	print(FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "percent.mt")+geom_hline(yintercept =mito_cutoff)+NoLegend())
  	print(FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")+geom_hline(yintercept =feat_min)+NoLegend())

  	obj
	seurat_objects[sample_name[1]] <- subset(obj, subset = percent.mt < mito_cutoff & nFeature_RNA > feat_min)
	print(seurat_objects[sample_name[1]])
}
```

### Run analysis pipeline and differential expression

```{r clustering}
exp <- seurat_objects[[1]]
if(length(seurat_objects)>1){
	for (i in 2:length(seurat_objects)){
		exp<-merge(exp,seurat_objects[[i]])
	}
}

exp <- exp %>% 
  SCTransform(verbose = FALSE) %>% 
  RunPCA() %>%
  FindNeighbors(dims = 1:30) %>% 
  RunUMAP(dims = 1:30) %>% 
  FindClusters(verbose = FALSE) %>% 
  PrepSCTFindMarkers() %>%
  Azimuth::RunAzimuth(reference ="mousecortexref")

s.genes <- str_to_title(cc.genes$s.genes)
g2m.genes <- str_to_title(cc.genes$g2m.genes)

exp <- CellCycleScoring(exp, s.features = s.genes, g2m.features = g2m.genes)

qsave(exp, file.path(save_dir, "scRNAseq.qs"))

clust_mark<-exp %>% FindAllMarkers(only.pos = TRUE)
write_tsv(clust_mark, file.path(save_dir, "cluster_markers.txt"))

Idents(exp) <- exp$orig.ident
sam_mark<-exp %>% FindAllMarkers(only.pos = TRUE)
write_tsv(sam_mark, file.path(save_dir, "sample_markers.txt"))

if (length(unique(exp$condition)) < length(unique(exp$orig.ident))){
  Idents(exp) <- exp$condition
  sam_mark<-exp %>% FindAllMarkers(only.pos = TRUE)
  write_tsv(sam_mark, file.path(save_dir, "condition_markers.txt"))
}
```

### Plots metrics to detect any anomalies in the data

```{r initialplots}

DimPlot(exp,split.by = "orig.ident")

for (idx in colnames(exp@meta.data)){
  if (is.numeric(exp@meta.data[[idx]])){
    print(FeaturePlot(exp, features = idx, pt.size = 0.2))
  }
  if (is.factor(exp@meta.data[[idx]]) || is.character(exp@meta.data[[idx]])){
    if (length(unique(exp@meta.data[[idx]])) > 10){
      print(DimPlot(exp, group.by = idx) + NoLegend())
    } else {
      print(DimPlot(exp, group.by = idx, label = FALSE))
    }
  }
}
```

## Plot highly variable genes

```{r markerplots}
#top 10 variable features
goi<-VariableFeatures(exp)[1:10]
#top 5 genes from each sample not in goi
goi <- c(goi,
         (sam_mark %>% 
            filter(!gene %in% goi) %>% 
            group_by(cluster) %>% 
            slice_head(n=5))
         $gene
         )
#top gene from each cluster not in goi
goi <- unique(c(goi,
                (clust_mark %>% 
                   filter(!gene %in% goi) %>% 
                   group_by(cluster) %>% 
                   slice_head(n=1))
                $gene
                )
              )

l<-length(goi)

for (i in seq(1,l,4)){
  print(FeaturePlot(exp,goi[i:(i+3)]))
}
```

### Run and plot velocity if TRUE

```{r create_velocity_objects, eval=velocity}
# pull velocyto data, filter cells, plot (only if velocity=TRUE)
velo_objects <- list()
for (idx in seq_along(cellranger_paths)) {
	path <- cellranger_paths[idx]
	sample_name <- metadata$name[idx]
	print(paste("Processing velocyto for sample:", sample_name))
	
	# generate object and filter
	vel <- ReadVelocity(paste0(path, "/velocyto/", sample_name, ".loom"))
	for(j in 1:length(vel)){
		rownames(vel[[j]]) <- make.unique(rownames(vel[[j]]))
		colnames(vel[[j]]) <- sub(".*:", "", sub("x", "-1", colnames(vel[[j]])))
	}
	vel <- as.Seurat(vel, project = sample_name)
	
	# filter to cells that exist in the corresponding seurat object
	velo_objects[[sample_name]] <- vel[, colnames(seurat_objects[[sample_name]])]
}

# merge velocity objects
velo_names <- names(velo_objects)
exp_velocity <- velo_objects[[velo_names[1]]]
if(length(velo_objects) > 1){
	for (i in 2:length(velo_objects)){
		exp_velocity <- merge(exp_velocity, velo_objects[[velo_names[i]]])
	}
}

DefaultAssay(exp_velocity) <- "spliced"
exp_velocity <- exp_velocity %>% 
  SCTransform(verbose = FALSE) %>% 
  RunPCA() %>%
  FindNeighbors(dims = 1:30) %>% 
  RunUMAP(dims = 1:30)

exp_velocity <- RunVelocity(object = exp_velocity, deltaT = 1, kCells = 25, fit.quantile = 0.02) 
Idents(exp_velocity) <- exp_velocity$orig.ident

qsave(exp_velocity, file.path(save_dir, "velocity.qs"))

# create color palette for velocity plot
n_idents <- length(levels(Idents(exp_velocity)))
ident.colors <- rainbow(n_idents)
names(ident.colors) <- levels(Idents(exp_velocity))
cell.colors <- ident.colors[Idents(exp_velocity)]
names(cell.colors) <- colnames(exp_velocity)
show.velocity.on.embedding.cor(emb = Embeddings(object = exp_velocity, reduction = "umap"), 
                               vel = Tool(object = exp_velocity, slot = "RunVelocity"), n = 200, 
                               scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5), 
                               cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, 
                               min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1, 
                               do.par = FALSE, cell.border.alpha = 0.1)
```

### Session Information

```{r end}
sessionInfo()
```
