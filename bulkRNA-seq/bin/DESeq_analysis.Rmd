---
title: "DESeq analysis"
author: "Jacqueline Roberts, PhD"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    embed-resources: true
    format: html5
params:
 collected_counts: ''
 database: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE,
                      cache = TRUE, cache.lazy = FALSE)

if (!require("pacman")) install.packages("pacman")

pacman::p_load(DESeq2,pheatmap,biomaRt,ggrepel,
               RColorBrewer,knitr,clusterProfiler,msigdbr,fgsea,openxlsx,tidyverse,rtracklayer)

set.seed(1234)

# read in nextflow channel inputs
collected_counts <- params$collected_counts
database <- params$database

#create directories for output
save_dir=c("DESeq_results")
dir.create(save_dir)
dir.create(file.path(save_dir,"plots"))
```

### I have aligned to `r database`

### First, parse the nextflow channel to generate DESeq input

```{r parse_nextflow_channel}
# nextflow collected channel tuple 
# [[id:x,name:x], counts, biotypes, [id:y,name:y], counts2, biotypes2]
# extract tuple contents by removing brackets
# [id:x, name:x], counts, biotypes, [id:y, name:y], counts2, biotypes2
clean_str <- substr(collected_counts, 2, nchar(collected_counts) - 1)
# parse individual sample information
# [id:x, name:x], counts, biotypes
# [id:y, name:y], counts2, biotypes2
sample_tuples <- strsplit(clean_str," \\[")[[1]]

# initialize metadata and counts tables
metadata <- tibble()
counts <- tibble()

# process each sample's data from the collected channel
for (sample_data in sample_tuples) {
  
  # extract metadata from entry
  # [id:x, name:x, condition:x, run:x, extras:x]
  meta_str <- str_extract(sample_data, "^[^\\]]*\\]")
  # remove brackets
  # id:x, name:x, condition:x, run:x, extras:x
  clean_str <- gsub("\\[|\\]", "", meta_str)
  
  # create a tibble
  meta_row <- as_tibble(strsplit(clean_str,", ")[[1]]) %>%
    separate_wider_delim(value,delim=":",names=c("title","val")) %>%
    pivot_wider(
        names_from = title,
        values_from = val
      ) %>%
    separate_wider_delim(extra,delim="|",names_sep = "_", too_few="align_start")
  
  # append to metadata table
  metadata <- bind_rows(metadata, meta_row)  
  
  # get count data
  # separate sample data by comma
  # [1] [id:x
  # [2] name:x]
  # [3] counts
  # [4] biotypes
  split_data<-strsplit(sample_data,", ")[[1]]
  # pull second to last entry as count_file
  count_file<-split_data[length(split_data) - 1]

  # read count file and extract gene IDs and counts
  sample_counts <- read_tsv(count_file, skip = 1) %>%
    select(Geneid, count = last_col())
  
  # if this is the first sample, initialize counts table
  if (nrow(counts) == 0) {
    counts <- sample_counts %>%
      rename(!!meta_row$name := count)
  } else {
    # append counts as new column
  counts <- counts %>%
      left_join(sample_counts %>% rename(!!meta_row$name := count), by = "Geneid")
  }
}

kable(metadata, caption = "Sample Metadata")
write_tsv(metadata, file.path(save_dir,"sample_metadata.tsv"))

kable(head(counts, 10), caption = "Transcript Counts")
write_tsv(counts, file.path(save_dir,"transcript_counts.tsv"))

```

### Next, run DESeq for different conditions

```{r run_DESeq}
# add count column names to metadata to detect count column order errors
coldata <- data.frame(metadata, 
                     name = colnames(counts)[-1],  # exclude Geneid
                     stringsAsFactors = TRUE)

# create DESeq2 dataset object with countData and colData (metadata)
dds <- DESeqDataSetFromMatrix(countData = counts[, -1],  # exclude Geneid
                             colData = coldata,
                             design = ~condition)

# set gene IDs as row names for the DESeq object
rownames(dds) <- counts$Geneid

# filter low-count genes
keep <- rowSums(counts(dds) >= 2) >= 2
dds <- dds[keep,]

cat("Filtered from", nrow(counts), "to", nrow(dds), "genes after low-count filtering\n")

# run the main DESeq2 analysis
dds <- DESeq(dds)

# save the DESeq2 results object
write_rds(dds, file.path(save_dir, "DESeq.rds"))
```

### Retrieve gene names to replace geneIDs

```{r gene_names}
# retrieve gene annotations from Ensembl using biomaRt with error handling
g <- tibble()

try({
  mart <- useMart(biomart = "ensembl", dataset = "mmusculus_gene_ensembl")

  # query biomaRt to get gene names for gene IDs
  g <- getBM(filters = "ensembl_gene_id",
             attributes = c("ensembl_gene_id", "external_gene_name",
                            "chromosome_name","description"),
             values = rownames(dds),
             mart = mart)
}, silent = TRUE)


# if biomaRt failed, try to load annotations from GTF file
if (nrow(g) == 0) {
  cat("biomaRt failed - trying to load annotations from GTF file\n")

  # Find GTF file in database directory (since gene_models is typically ${database}/*gtf)
  gtf_files <- Sys.glob(file.path(database, "*gtf"))

  if (length(gtf_files) > 0) {
    cat("Found GTF file:", gtf_files[1], "\n")

    try({
      # Read GTF file using rtracklayer
      gtf <- import(gtf_files[1])

      # Extract gene-level annotations
      genes <- gtf[gtf$type == "gene"]

      # Create annotation table
      g <- tibble(
        ensembl_gene_id = genes$gene_id,
        external_gene_name = ifelse(is.na(genes$gene_name), genes$gene_id, genes$gene_name),
        chromosome_name = as.character(seqnames(genes)),
        gene_biotype = genes$gene_biotype
      ) %>%
        filter(ensembl_gene_id %in% rownames(dds)) %>%
        distinct(ensembl_gene_id, .keep_all = TRUE)
    }, silent = TRUE)
  }

  # if GTF loading also failed, create dummy annotations
  if (nrow(g) == 0) {
    cat("GTF loading failed - creating dummy gene annotations\n")
    g <- tibble(
      ensembl_gene_id = rownames(dds),
      external_gene_name = rownames(dds),
      chromosome_name = "unknown",
      description = "unknown"
    )
  }
}

cat("Retrieved gene names for", nrow(g), "out of", nrow(dds), "transcripts\n")

# add gene names to the counts table
# left_join ensures we keep all genes even if some don't have names
counts <- counts %>% 
  dplyr::rename(ensembl_gene_id = Geneid) %>%
  left_join(g, by = "ensembl_gene_id")

# save annotated counts table
write_tsv(counts, file.path(save_dir, "gene_counts.tsv"))
```

### Quality control plots to assess sample similarity and batch effects

```{r plots}
# apply vst normalization for visualizations
vsd <- vst(dds, blind = FALSE)

# sample-to-sample distance heatmap
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
colnames(sampleDistMatrix) <- NULL  # remove column names for cleaner plot
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

p <- pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         main = "Sample-to-Sample Distances")

print(p)
ggsave(file.path(save_dir, "plots", "sample_distances.png"), plot = p)

# PCA plot
pca_plot <- plotPCA(vsd, intgroup = c("name")) +
  geom_text_repel(aes(label = name), color = "black", size = 3) +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Principal Component Analysis")

print(pca_plot)
ggsave(file.path(save_dir, "plots", "PCA_plot.png"), 
       plot = pca_plot, width = 10, height = 8)
```

### Differential expression analysis

```{r DE_results}
# get all mouse MSigDB collections for GSEA
all_msig <- msigdbr(species = "Mus musculus",db_species = "MM")

# create nested list: collections -> pathways -> genes
msig_sets <- all_msig %>%
  split(.$gs_collection_name) %>%  # split by subcategory first
  map(~ split(.x$ensembl_gene, .x$gs_name))  # then split genes by pathway name

# remove empty subcategories
msig_sets <- msig_sets[lengths(msig_sets) > 0]

cat("Available gene set collections:", names(msig_sets), "\n")

# get all unique condition pairs for pairwise comparisons
condition_pairs <- combn(as.character(unique(colData(dds)$condition)), 2, simplify = FALSE)

# loop through each unique pair
for (pair in condition_pairs) {
  con1 <- pair[1]
  con2 <- pair[2]
  comparison_name <- paste0(con1, "_vs_", con2)
  
  cat("\n### Comparing", con1, "vs", con2, "\n")
  # get results from DESeq comparing the two conditions
  res <- results(dds, contrast = c("condition", con1, con2)) %>%
    as.data.frame() %>%
    rownames_to_column("ensembl_gene_id") %>%
    left_join(g, by = "ensembl_gene_id") %>%
    mutate(padj = replace_na(padj, 1)) %>%
    arrange(padj)
  
  # save pairwise comparison with gene names
  write_tsv(res, file.path(save_dir, paste0("DE_", comparison_name, ".tsv")))
  
  # volcano plot of differentially expressed genes
  sig_genes <- filter(res, padj < 0.05)
  
  volcano_plot <- ggplot(res, aes(log2FoldChange, -log10(padj + 1e-300))) +
    geom_point(alpha = 0.6) +
    geom_point(data = sig_genes, color = "red") +
    geom_text_repel(data = slice_min(sig_genes, padj, n = 20) %>%
                          slice_max(abs(log2FoldChange), n = 20), 
                   aes(label = external_gene_name), size = 3) +
    theme_bw() +
    labs(title = paste("Volcano Plot:", comparison_name),
         x = paste("log2 Fold Change (", con1, "vs", con2, ")"),
         y = "-log10(adjusted p-value)")
  
  print(volcano_plot)
  ggsave(file.path(save_dir, "plots", paste0("volcano_", comparison_name, ".png")), 
         plot = volcano_plot, width = 10, height = 8)
  
  cat("Significant genes (padj < 0.05):", nrow(sig_genes), "\n") 

  # data for 20 differentially expressed transcrips
  select <- (slice_min(sig_genes, padj, n = 20) %>%
        slice_max(abs(log2FoldChange), n = 20))$ensembl_gene_id

  # prepare with gene name instead of IDs
  heatmap_data <- as.data.frame(assay(vsd)[select, ]) %>% 
    rownames_to_column("ensembl_gene_id") %>% 
    left_join(g[,1:2], by = "ensembl_gene_id") %>% 
    select(-ensembl_gene_id) %>%
    column_to_rownames("external_gene_name")

  # create heatmap of top expressed genes
  p <- pheatmap(heatmap_data, 
           main = "Top 20 Differentially Expressed Genes")

  print(p)
  ggsave(file.path(save_dir, "plots", paste0("top_DE_genes_",comparison_name,"_heatmap.png")), plot = p)

  # gene set enrichment analysis (GSEA)
  # create ranked gene list for GSEA (sorted by log2FoldChange)
  gene_list <- res$log2FoldChange
  names(gene_list) <- res$ensembl_gene_id
  gene_list <- sort(gene_list, decreasing = TRUE)
  
  # remove genes without Ensembl IDs
  #gene_list <- gene_list[!is.na(names(gene_list))]
  
  cat("Running GSEA with", length(gene_list), "ranked genes\n")
  
  # create Excel workbook for this comparison 
  xl_filename <- paste0("GSEA_", comparison_name, ".xlsx")
  wb <- createWorkbook()
  
  # run GSEA for selected collections (limit to avoid too many results)
  selected_collections <- c("Hallmark", "GO Biological Process", 
                            "GO Molecular Function", "WikiPathways")
  available_collections <- intersect(selected_collections, names(msig_sets))
  
  for (collection_name in available_collections) {
    cat("Analyzing", collection_name, "gene sets...\n")
    
    # run fgsea
    fgsea_res <- suppressMessages(suppressWarnings({
      capture.output(
        fgsea_result <- fgsea::fgsea(pathways = msig_sets[[collection_name]],
                                    stats = gene_list,
                                    minSize = 15,
                                    maxSize = 500,
                                    nproc = 1),
        type = "message"
      )
      fgsea_result
    })) %>%
      as.data.frame() %>%
      arrange(padj) %>%
      filter(padj < 0.05)
    
    if (nrow(fgsea_res) > 0) {
      # add worksheet for this collection
      addWorksheet(wb, collection_name)
      writeData(wb, collection_name, fgsea_res)
      cat("Found", nrow(fgsea_res), "significant pathways in", collection_name, "\n")

      # Print top 5 significant pathways
      top_pathways <- head(filter(fgsea_res,padj<0.05), 5)
      cat("Top", min(5, nrow(fgsea_res)), "pathways:\n")
      for (i in 1:nrow(top_pathways)) {
        cat(sprintf("  %d. %s (padj=%.3e, NES=%.2f)\n",
                   i, top_pathways$pathway[i], top_pathways$padj[i], top_pathways$NES[i]))
      }
      cat("\n")
    }
  }
  
  # save workbook
  saveWorkbook(wb, file.path(save_dir, xl_filename), overwrite = TRUE)
}


```

### Analysis Summary

```{r summary}
# create a summary table of all pairwise comparisons
summary_results <- tibble()

for (pair in condition_pairs) {
  con1 <- pair[1]
  con2 <- pair[2]
  comparison_name <- paste0(con1, "_vs_", con2)
  
  # read back the results file to get summary stats
  res_file <- file.path(save_dir, paste0("DE_", comparison_name, ".tsv"))
  if (file.exists(res_file)) {
    res <- read_tsv(res_file, show_col_types = FALSE)
    
    # calculate summary statistics
    total_genes <- nrow(res)
    sig_genes <- sum(res$padj < 0.05, na.rm = TRUE)
    upregulated <- sum(res$padj < 0.05 & res$log2FoldChange > 0, na.rm = TRUE)
    downregulated <- sum(res$padj < 0.05 & res$log2FoldChange < 0, na.rm = TRUE)
    
    summary_results <- bind_rows(summary_results, 
                                tibble(
                                  comparison = comparison_name,
                                  total_genes = total_genes,
                                  significant = sig_genes,
                                  upregulated = upregulated,
                                  downregulated = downregulated,
                                  percent_significant = round(100 * sig_genes / total_genes, 1)
                                ))
  }
}

kable(summary_results, caption = "Summary of Differential Expression Results")
write_tsv(summary_results, file.path(save_dir, "DE_summary.tsv"))
```

### Session Information

```{r session_info}
# record all package versions and system information for reproducibility
sessionInfo()
```
